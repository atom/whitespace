const {CompositeDisposable, Point, Range} = require('atom')

const TRAILING_WHITESPACE_REGEX = /[ \t]+(?=\r?$)/g

module.exports = class Whitespace {
  constructor () {
    this.watchedEditors = new WeakSet()
    this.subscriptions = new CompositeDisposable()
    /* This map is used to control cursors in multiple tab
      The key is the TextEditor.id field, as it seems to be unique and stable
      over buffer renaming
      The value is an array of row positions.
        When inserting text (whatever the text inserted), each row is checked
        and cleaned. The set is cleared after each insertion
        When moving the cursor, the old row position is stored
    */
    this.mapOfOldCursorPositions = new Map()
    /* This variable holds the status of the update process
       When we are removing whitespaces lines, we don't want to process
       onDidChange events generated by these removals
    */
    this.currentlyRemovingWhitespacesLines = false
    /* This variable is used to tell if during the last change we updated the
       indentation or not. This is used to manage the history
    */
    this.hasUpdatedIndentation = false
    /* This variable is true when the text inserted is blank only */
    this.insertedTextIsBlank = false

    this.groupLastEventWasIndentUpdate = false

    this.subscriptions.add(atom.workspace.observeTextEditors(editor => {
      return this.handleEvents(editor)
    }))

    this.subscriptions.add(atom.commands.add('atom-workspace', {
      'whitespace:remove-trailing-whitespace': () => {
        let editor = atom.workspace.getActiveTextEditor()

        if (editor) {
          this.removeTrailingWhitespace(editor, editor.getGrammar().scopeName)
        }
      },

      'whitespace:save-with-trailing-whitespace': async () => {
        let editor = atom.workspace.getActiveTextEditor()

        if (editor) {
          this.ignore = true
          await editor.save()
          this.ignore = false
        }
      },

      'whitespace:save-without-trailing-whitespace': () => {
        let editor = atom.workspace.getActiveTextEditor()

        if (editor) {
          this.removeTrailingWhitespace(editor, editor.getGrammar().scopeName)
          editor.save()
        }
      },

      'whitespace:convert-tabs-to-spaces': () => {
        let editor = atom.workspace.getActiveTextEditor()

        if (editor) {
          this.convertTabsToSpaces(editor)
        }
      },

      'whitespace:convert-spaces-to-tabs': () => {
        let editor = atom.workspace.getActiveTextEditor()

        if (editor) {
          return this.convertSpacesToTabs(editor)
        }
      },

      'whitespace:convert-all-tabs-to-spaces': () => {
        let editor = atom.workspace.getActiveTextEditor()

        if (editor) {
          return this.convertTabsToSpaces(editor, true)
        }
      }
    }))
  }

  destroy () {
    return this.subscriptions.dispose()
  }

  // Retrieve the right array for the current TextEditor
  getCurrentEditorArray () {
    let id = atom.workspace.getActiveTextEditor().id
    let mapOld = this.mapOfOldCursorPositions
    if (!mapOld.has(id)) {
      mapOld.set(id, [])
    }
    return mapOld.get(id)
  }

  // Check that the row in the given buffer is eligible for being stored
  // A row is considered eligible if it's not empty and if only blank filled
  isBufferRowEligible (buffer, row) {
    return buffer.lineLengthForRow(row) && buffer.isRowBlank(row)
  }

  // Store a row in the current array, if it doesn't already exist (set-like storage)
  appendRowCurrentBuffer (row) {
    let curArray = this.getCurrentEditorArray()
    if (curArray.indexOf(row) === -1) {
      curArray.push(row)
    }
  }

  // This function actually cleans the rows that are only filled with blanks
  // As it cleans the rows, it also clears the array storing the rows
  updateAndClearCurrentBufferEmptyRows (buffer) {
    // Flag set to true to tell other functions where the change event comes from
    this.currentlyRemovingWhitespacesLines = true
    // Group the changes into one history entity, so that several newlines can be
    // undo/redo as one history event
    this.hasUpdatedIndentation = 0
    buffer.transact(() => {
      let curArray = this.getCurrentEditorArray()
      while (curArray.length) {
        let v = curArray.pop()
        if (this.isBufferRowEligible(buffer, v)) {
          atom.workspace.getActiveTextEditor().setIndentationForBufferRow(v, 0)
          this.hasUpdatedIndentation = 1
        }
      }
      if (!this.hasUpdatedIndentation) {
        buffer.abortTransaction()
      }
    })

    // Unset the flag
    this.currentlyRemovingWhitespacesLines = false
  }

  // This function updates the rows saved when lines are added
  //   from : row where the insertion happened
  //   altered : number or lines added/removed
  // If a saved-row does not exist anymore after a deletion occurs, this function
  // will remove it
  updateSavedRows (from, altered) {
    let curArray = this.getCurrentEditorArray()
    let i = 0
    while (i < curArray.length) {
      if (curArray[i] > from) {
        curArray[i] += altered
      }
      if (curArray[i] < 0) {
        curArray.splice(i, 1)
      } else {
        ++i
      }
    }
  }

  // Get the state of the ensureNoBlankLinesLeft configuration state
  isNoBlankLinesLeftActivated (editor) {
    return atom.config.get('whitespace.ensureNoBlankLinesLeft', {
      scope: editor.getRootScopeDescriptor()
    })
  }

  handleEvents (editor) {
    if (this.watchedEditors.has(editor)) {
      return
    }

    let subArray = []

    let buffer = editor.getBuffer()

    subArray.push(buffer.onWillSave(() => {
      return buffer.transact(() => {
        let scopeDescriptor = editor.getRootScopeDescriptor()

        if (atom.config.get('whitespace.removeTrailingWhitespace', {
          scope: scopeDescriptor
        }) && !this.ignore) {
          this.removeTrailingWhitespace(editor, editor.getGrammar().scopeName)
        }

        if (atom.config.get('whitespace.ensureSingleTrailingNewline', {scope: scopeDescriptor})) {
          return this.ensureSingleTrailingNewline(editor)
        }
      })
    }))

    subArray.push(editor.onDidDestroy(event => {
      // Get rid of informations corresponding to the recently closed editor
      this.mapOfOldCursorPositions.delete(editor.id)
    }))

    subArray.push(buffer.onDidChange(event => {
      if (!this.isNoBlankLinesLeftActivated(editor)) {
        return
      }

      // If this event happened during our update, discard it
      if (this.currentlyRemovingWhitespacesLines) {
        return
      }

      // Update the rows depending on the changes reported (insertion/deletion)
      let altered = []

      event.changes.forEach(val => {
        const row = val.newRange.start.row
        // row : the row where the change occured
        // alt : final number of lines added/removed
        altered.push({
          row: row,
          alt: (val.newRange.end.row - row) - (val.oldRange.end.row - val.oldRange.start.row)
        })
      })

      // Keep the array sorted, so that we loop from the lowest row index
      altered.sort((a, b) => {
        if (a.row < b.row) {
          return -1
        }
        return a.row > b.row
      })

      altered.forEach((val) => this.updateSavedRows(val.row, val.alt))

      this.updateAndClearCurrentBufferEmptyRows(buffer)

      if (this.hasUpdatedIndentation) {
        if (this.groupLastEventWasIndentUpdate) {
          buffer.groupLastChanges()
        }
        buffer.groupLastChanges()
      }
      this.groupLastEventWasIndentUpdate = this.hasUpdatedIndentation && this.insertedTextIsBlank
    }))

    subArray.push(editor.onWillInsertText(event => {
      if (!this.isNoBlankLinesLeftActivated(editor)) {
        return
      }

      // based on TextBuffer.rowIsBlank source : test if string is blank.
      this.insertedTextIsBlank = /\s/.test(event.text)
      /* if the text about to be inserted is blank only and don't contains newline, do not try to save the rows
      Maybe we could implement a TextBuffer.stringIsBlank...
      */
      if (this.insertedTextIsBlank && /[^\n]/.test(event.text)) {
        return
      }
      editor.getCursorBufferPositions().forEach(pos => {
        this.appendRowCurrentBuffer(pos.row)
      })
    }))

    subArray.push(editor.onDidChangeCursorPosition(event => {
      if (!this.isNoBlankLinesLeftActivated(editor)) {
        return
      }

      // If the text changed, discard (onDidChange will be called)
      if (event.textChanged) {
        return
      }
      // If we moved on the current line, discard
      if (event.oldBufferPosition.row === event.newBufferPosition.row) {
        return
      }

      this.hasUpdatedIndentation = 0
      this.appendRowCurrentBuffer(event.oldBufferPosition.row)
    }))

    editor.onDidDestroy(() => {
      subArray.forEach((sub) => {
        sub.dispose()
        this.subscriptions.remove(sub)
      })
      this.watchedEditors.delete(editor)
    })

    subArray.forEach((sub) => {
      this.subscriptions.add(sub)
    })

    this.watchedEditors.add(editor)
  }

  removeTrailingWhitespace (editor, grammarScopeName) {
    const buffer = editor.getBuffer()
    const scopeDescriptor = editor.getRootScopeDescriptor()

    // When buffer is same buffer of activeEditor's buffer, don't remove
    // trailing WS at activeEditor's cursor line.
    const activeEditor = atom.workspace.getActiveTextEditor()
    const cursorRows =
      activeEditor && activeEditor.getBuffer() === buffer
        ? new Set(activeEditor.getCursors().map(cursor => cursor.getBufferRow()))
        : new Set()

    const ignoreCurrentLine = atom.config.get('whitespace.ignoreWhitespaceOnCurrentLine', {
      scope: scopeDescriptor
    })

    const ignoreWhitespaceOnlyLines = atom.config.get('whitespace.ignoreWhitespaceOnlyLines', {
      scope: scopeDescriptor
    })

    const keepMarkdownLineBreakWhitespace =
      grammarScopeName === ('source.gfm' || 'text.md') &&
      atom.config.get('whitespace.keepMarkdownLineBreakWhitespace')

    buffer.transact(() => {
      // TODO - remove this conditional after Atom 1.19 stable is released.
      if (buffer.findAllSync) {
        const ranges = buffer.findAllSync(TRAILING_WHITESPACE_REGEX)
        for (let i = 0, n = ranges.length; i < n; i++) {
          const range = ranges[i]
          const row = range.start.row
          const trailingWhitespaceStart = ranges[i].start.column
          if (ignoreCurrentLine && cursorRows.has(row)) continue
          if (ignoreWhitespaceOnlyLines && trailingWhitespaceStart === 0) continue
          if (keepMarkdownLineBreakWhitespace) {
            const whitespaceLength = range.end.column - range.start.column
            if (trailingWhitespaceStart > 0 && whitespaceLength >= 2) continue
          }
          buffer.delete(ranges[i])
        }
      } else {
        for (let row = 0, lineCount = buffer.getLineCount(); row < lineCount; row++) {
          const line = buffer.lineForRow(row)
          const lastCharacter = line[line.length - 1]
          if (lastCharacter === ' ' || lastCharacter === '\t') {
            const trailingWhitespaceStart = line.search(TRAILING_WHITESPACE_REGEX)
            if (ignoreCurrentLine && cursorRows.has(row)) continue
            if (ignoreWhitespaceOnlyLines && trailingWhitespaceStart === 0) continue
            if (keepMarkdownLineBreakWhitespace) {
              const whitespaceLength = line.length - trailingWhitespaceStart
              if (trailingWhitespaceStart > 0 && whitespaceLength >= 2) continue
            }
            buffer.delete(Range(Point(row, trailingWhitespaceStart), Point(row, line.length)))
          }
        }
      }
    })
  }

  ensureSingleTrailingNewline (editor) {
    let selectedBufferRanges
    let row
    let buffer = editor.getBuffer()
    let lastRow = buffer.getLastRow()

    if (buffer.lineForRow(lastRow) === '') {
      row = lastRow - 1

      while (row && buffer.lineForRow(row) === '') {
        buffer.deleteRow(row--)
      }
    } else {
      selectedBufferRanges = editor.getSelectedBufferRanges()
      buffer.append('\n')
      editor.setSelectedBufferRanges(selectedBufferRanges)
    }
  }

  convertTabsToSpaces (editor, convertAllTabs) {
    let buffer = editor.getBuffer()
    let spacesText = new Array(editor.getTabLength() + 1).join(' ')
    let regex = (convertAllTabs ? /\t/g : /^\t+/g)

    buffer.transact(function () {
      return buffer.scan(regex, function ({replace}) {
        return replace(spacesText)
      })
    })

    return editor.setSoftTabs(true)
  }

  convertSpacesToTabs (editor) {
    let buffer = editor.getBuffer()
    let scope = editor.getRootScopeDescriptor()
    let fileTabSize = editor.getTabLength()

    let userTabSize = atom.config.get('editor.tabLength', {
      scope: scope
    })

    let regex = new RegExp(' '.repeat(fileTabSize), 'g')

    buffer.transact(function () {
      return buffer.scan(/^[ \t]+/g, function ({matchText, replace}) {
        return replace(matchText.replace(regex, '\t').replace(/[ ]+\t/g, '\t'))
      })
    })

    editor.setSoftTabs(false)

    if (fileTabSize !== userTabSize) {
      return editor.setTabLength(userTabSize)
    }
  }
}
